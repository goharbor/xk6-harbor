// Code generated by go-swagger; DO NOT EDIT.

package gc

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"

	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

//go:generate mockery --name API --keeptree --with-expecter --case underscore

// API is the interface of the gc client
type API interface {
	/*
	   CreateGCSchedule creates a gc schedule

	   This endpoint is for update gc schedule.
	*/
	CreateGCSchedule(ctx context.Context, params *CreateGCScheduleParams) (*CreateGCScheduleCreated, error)
	/*
	   GetGC gets gc status

	   This endpoint let user get gc status filtered by specific ID.*/
	GetGC(ctx context.Context, params *GetGCParams) (*GetGCOK, error)
	/*
	   GetGCHistory gets gc results

	   This endpoint let user get gc execution history.*/
	GetGCHistory(ctx context.Context, params *GetGCHistoryParams) (*GetGCHistoryOK, error)
	/*
	   GetGCLog gets gc job log

	   This endpoint let user get gc job logs filtered by specific ID.*/
	GetGCLog(ctx context.Context, params *GetGCLogParams) (*GetGCLogOK, error)
	/*
	   GetGCSchedule gets gc s schedule

	   This endpoint is for get schedule of gc job.*/
	GetGCSchedule(ctx context.Context, params *GetGCScheduleParams) (*GetGCScheduleOK, error)
	/*
	   StopGC stops the specific GC execution

	   Stop the GC execution specified by ID*/
	StopGC(ctx context.Context, params *StopGCParams) (*StopGCOK, error)
	/*
	   UpdateGCSchedule updates gc s schedule

	   This endpoint is for update gc schedule.
	*/
	UpdateGCSchedule(ctx context.Context, params *UpdateGCScheduleParams) (*UpdateGCScheduleOK, error)
}

// New creates a new gc API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry, authInfo runtime.ClientAuthInfoWriter) *Client {
	return &Client{
		transport: transport,
		formats:   formats,
		authInfo:  authInfo,
	}
}

/*
Client for gc API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
	authInfo  runtime.ClientAuthInfoWriter
}

/*
CreateGCSchedule creates a gc schedule

This endpoint is for update gc schedule.
*/
func (a *Client) CreateGCSchedule(ctx context.Context, params *CreateGCScheduleParams) (*CreateGCScheduleCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createGCSchedule",
		Method:             "POST",
		PathPattern:        "/system/gc/schedule",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateGCScheduleReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *CreateGCScheduleCreated:
		return value, nil
	case *CreateGCScheduleBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreateGCScheduleUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreateGCScheduleForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreateGCScheduleConflict:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreateGCScheduleInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createGCSchedule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetGC gets gc status

This endpoint let user get gc status filtered by specific ID.
*/
func (a *Client) GetGC(ctx context.Context, params *GetGCParams) (*GetGCOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getGC",
		Method:             "GET",
		PathPattern:        "/system/gc/{gc_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetGCReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *GetGCOK:
		return value, nil
	case *GetGCUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetGCForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetGCNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetGCInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getGC: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetGCHistory gets gc results

This endpoint let user get gc execution history.
*/
func (a *Client) GetGCHistory(ctx context.Context, params *GetGCHistoryParams) (*GetGCHistoryOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getGCHistory",
		Method:             "GET",
		PathPattern:        "/system/gc",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetGCHistoryReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *GetGCHistoryOK:
		return value, nil
	case *GetGCHistoryUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetGCHistoryForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetGCHistoryInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getGCHistory: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetGCLog gets gc job log

This endpoint let user get gc job logs filtered by specific ID.
*/
func (a *Client) GetGCLog(ctx context.Context, params *GetGCLogParams) (*GetGCLogOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getGCLog",
		Method:             "GET",
		PathPattern:        "/system/gc/{gc_id}/log",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetGCLogReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *GetGCLogOK:
		return value, nil
	case *GetGCLogBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetGCLogUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetGCLogForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetGCLogNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetGCLogInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getGCLog: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetGCSchedule gets gc s schedule

This endpoint is for get schedule of gc job.
*/
func (a *Client) GetGCSchedule(ctx context.Context, params *GetGCScheduleParams) (*GetGCScheduleOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getGCSchedule",
		Method:             "GET",
		PathPattern:        "/system/gc/schedule",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetGCScheduleReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *GetGCScheduleOK:
		return value, nil
	case *GetGCScheduleUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetGCScheduleForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetGCScheduleInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getGCSchedule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopGC stops the specific GC execution

Stop the GC execution specified by ID
*/
func (a *Client) StopGC(ctx context.Context, params *StopGCParams) (*StopGCOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "stopGC",
		Method:             "PUT",
		PathPattern:        "/system/gc/{gc_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StopGCReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *StopGCOK:
		return value, nil
	case *StopGCUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *StopGCForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *StopGCNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *StopGCInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for stopGC: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateGCSchedule updates gc s schedule

This endpoint is for update gc schedule.
*/
func (a *Client) UpdateGCSchedule(ctx context.Context, params *UpdateGCScheduleParams) (*UpdateGCScheduleOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateGCSchedule",
		Method:             "PUT",
		PathPattern:        "/system/gc/schedule",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateGCScheduleReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *UpdateGCScheduleOK:
		return value, nil
	case *UpdateGCScheduleBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdateGCScheduleUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdateGCScheduleForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdateGCScheduleInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateGCSchedule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}
