// Code generated by go-swagger; DO NOT EDIT.

package purge

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"

	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

//go:generate mockery --name API --keeptree --with-expecter --case underscore

// API is the interface of the purge client
type API interface {
	/*
	   CreatePurgeSchedule creates a purge job schedule

	   This endpoint is for update purge job schedule.
	*/
	CreatePurgeSchedule(ctx context.Context, params *CreatePurgeScheduleParams) (*CreatePurgeScheduleCreated, error)
	/*
	   GetPurgeHistory gets purge job results

	   get purge job execution history.*/
	GetPurgeHistory(ctx context.Context, params *GetPurgeHistoryParams) (*GetPurgeHistoryOK, error)
	/*
	   GetPurgeJob gets purge job status

	   This endpoint let user get purge job status filtered by specific ID.*/
	GetPurgeJob(ctx context.Context, params *GetPurgeJobParams) (*GetPurgeJobOK, error)
	/*
	   GetPurgeJobLog gets purge job log

	   This endpoint let user get purge job logs filtered by specific ID.*/
	GetPurgeJobLog(ctx context.Context, params *GetPurgeJobLogParams) (*GetPurgeJobLogOK, error)
	/*
	   GetPurgeSchedule gets purge s schedule

	   This endpoint is for get schedule of purge job.*/
	GetPurgeSchedule(ctx context.Context, params *GetPurgeScheduleParams) (*GetPurgeScheduleOK, error)
	/*
	   StopPurge stops the specific purge audit log execution

	   Stop the purge audit log execution specified by ID*/
	StopPurge(ctx context.Context, params *StopPurgeParams) (*StopPurgeOK, error)
	/*
	   UpdatePurgeSchedule updates purge job s schedule

	   This endpoint is for update purge job schedule.
	*/
	UpdatePurgeSchedule(ctx context.Context, params *UpdatePurgeScheduleParams) (*UpdatePurgeScheduleOK, error)
}

// New creates a new purge API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry, authInfo runtime.ClientAuthInfoWriter) *Client {
	return &Client{
		transport: transport,
		formats:   formats,
		authInfo:  authInfo,
	}
}

/*
Client for purge API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
	authInfo  runtime.ClientAuthInfoWriter
}

/*
CreatePurgeSchedule creates a purge job schedule

This endpoint is for update purge job schedule.
*/
func (a *Client) CreatePurgeSchedule(ctx context.Context, params *CreatePurgeScheduleParams) (*CreatePurgeScheduleCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createPurgeSchedule",
		Method:             "POST",
		PathPattern:        "/system/purgeaudit/schedule",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreatePurgeScheduleReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *CreatePurgeScheduleCreated:
		return value, nil
	case *CreatePurgeScheduleBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreatePurgeScheduleUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreatePurgeScheduleForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreatePurgeScheduleInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createPurgeSchedule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetPurgeHistory gets purge job results

get purge job execution history.
*/
func (a *Client) GetPurgeHistory(ctx context.Context, params *GetPurgeHistoryParams) (*GetPurgeHistoryOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getPurgeHistory",
		Method:             "GET",
		PathPattern:        "/system/purgeaudit",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetPurgeHistoryReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *GetPurgeHistoryOK:
		return value, nil
	case *GetPurgeHistoryUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetPurgeHistoryForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetPurgeHistoryInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getPurgeHistory: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetPurgeJob gets purge job status

This endpoint let user get purge job status filtered by specific ID.
*/
func (a *Client) GetPurgeJob(ctx context.Context, params *GetPurgeJobParams) (*GetPurgeJobOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getPurgeJob",
		Method:             "GET",
		PathPattern:        "/system/purgeaudit/{purge_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetPurgeJobReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *GetPurgeJobOK:
		return value, nil
	case *GetPurgeJobUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetPurgeJobForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetPurgeJobNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetPurgeJobInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getPurgeJob: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetPurgeJobLog gets purge job log

This endpoint let user get purge job logs filtered by specific ID.
*/
func (a *Client) GetPurgeJobLog(ctx context.Context, params *GetPurgeJobLogParams) (*GetPurgeJobLogOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getPurgeJobLog",
		Method:             "GET",
		PathPattern:        "/system/purgeaudit/{purge_id}/log",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetPurgeJobLogReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *GetPurgeJobLogOK:
		return value, nil
	case *GetPurgeJobLogBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetPurgeJobLogUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetPurgeJobLogForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetPurgeJobLogNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetPurgeJobLogInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getPurgeJobLog: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetPurgeSchedule gets purge s schedule

This endpoint is for get schedule of purge job.
*/
func (a *Client) GetPurgeSchedule(ctx context.Context, params *GetPurgeScheduleParams) (*GetPurgeScheduleOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getPurgeSchedule",
		Method:             "GET",
		PathPattern:        "/system/purgeaudit/schedule",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetPurgeScheduleReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *GetPurgeScheduleOK:
		return value, nil
	case *GetPurgeScheduleUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetPurgeScheduleForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetPurgeScheduleInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getPurgeSchedule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPurge stops the specific purge audit log execution

Stop the purge audit log execution specified by ID
*/
func (a *Client) StopPurge(ctx context.Context, params *StopPurgeParams) (*StopPurgeOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "stopPurge",
		Method:             "PUT",
		PathPattern:        "/system/purgeaudit/{purge_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StopPurgeReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *StopPurgeOK:
		return value, nil
	case *StopPurgeUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *StopPurgeForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *StopPurgeNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *StopPurgeInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for stopPurge: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdatePurgeSchedule updates purge job s schedule

This endpoint is for update purge job schedule.
*/
func (a *Client) UpdatePurgeSchedule(ctx context.Context, params *UpdatePurgeScheduleParams) (*UpdatePurgeScheduleOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updatePurgeSchedule",
		Method:             "PUT",
		PathPattern:        "/system/purgeaudit/schedule",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdatePurgeScheduleReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *UpdatePurgeScheduleOK:
		return value, nil
	case *UpdatePurgeScheduleBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdatePurgeScheduleUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdatePurgeScheduleForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdatePurgeScheduleInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updatePurgeSchedule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}
